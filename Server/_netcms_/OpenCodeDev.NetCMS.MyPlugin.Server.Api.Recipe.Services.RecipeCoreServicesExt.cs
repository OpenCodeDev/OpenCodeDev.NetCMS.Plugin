/*
-- GENERATED BY NetCMS-Cli v0.1.0 BUILD 1200 -- 
Created on 7/21/2021 9:56:29 PM
Repos CLI: https://github.com/OpenCodeDev/OpenCodeDev.NetCMS.Compiler
License: MIT
Author: Max Samson
Company: OpenCodeDev
*/


using Grpc.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

//NetCMS Server Core System
using OpenCodeDev.NetCMS.Core.Server.Api;

//NetCMS Shared Core System
using OpenCodeDev.NetCMS.Core.Shared.Api.Messages;
using OpenCodeDev.NetCMS.Core.Shared.Extensions;

// Code Namespaces
using OpenCodeDev.NetCms.Shared.Api.Recipe.Models;
using OpenCodeDev.NetCms.Shared.Api.Recipe.Messages;

// Server Resources
using OpenCodeDev.NetCMS.MyPlugin.Server.Database;
using OpenCodeDev.NetCMS.MyPlugin.Server.Api.Recipe.Models;

namespace OpenCodeDev.NetCMS.MyPlugin.Server.Api.Recipe.Services
{

    // AUTO-GENERATE DO NOT EDIT

    /// <summary>
    /// Provide service with vital extension for Search System, Ordering System, Filter System and much more.
    /// </summary>
    public static class RecipeCoreServicesExt
    {
                /// <summary>
        /// Query where given field condition are met.
        /// </summary>
        public static IQueryable<RecipeModel> WhereConditionsMet(this IQueryable<RecipeModel> query, List<RecipePredicateConditions> conditions)
        {
            if (conditions == null) { return query; }
            bool nextFollowsLogic = false;
            ApiServiceBase myServiceBase = new ApiServiceBase();
            LogicTypes? nextBreakingLogic = null;
            Expression<Func<RecipeModel, bool>> expr = null;
            Expression<Func<RecipeModel, bool>> currentExpr = null;
            foreach (var item in conditions)
            {
                Expression<Func<RecipeModel, bool>> nonRelationField = null;
                switch (item.Field)
                {
                    case RecipePredicateConditions.Fields.Name: 
 nonRelationField = p => myServiceBase.ConditionTypeDelegator(item.Conditions, p.Name, item.Value, typeof(System.String)); break;
case RecipePredicateConditions.Fields.Duration: 
 nonRelationField = p => myServiceBase.ConditionTypeDelegator(item.Conditions, p.Duration, item.Value, typeof(System.Int32)); break;
                    // case RecipePredicateConditions.Fields.Duration:
                    //     nonRelationField = p => myServiceBase.ConditionTypeDelegator(item.Conditions, p.Duration, item.Value, typeof(Int32));
                    //     break;
                    // case RecipePredicateConditions.Fields.Name:
                    //     nonRelationField = p => myServiceBase.ConditionTypeDelegator(item.Conditions, p.Duration, item.Value, typeof(Int32));
                    //     break;
                    default:
                        break;
                }


                if (!nextFollowsLogic)
                {
                    currentExpr = nonRelationField;

                }
                else if (item.LogicalOperator == LogicTypes.And || item.LogicalOperator == LogicTypes.Or)
                {
                    if (expr == null) { expr = currentExpr; }
                    else if (expr != null && currentExpr != null && nextBreakingLogic != null && nextBreakingLogic == LogicTypes.And)
                    {
                        expr = Expression.Lambda<Func<RecipeModel, bool>>(Expression.And(expr.Body, new ExpressionParameterReplacer(currentExpr.Parameters, expr.Parameters).Visit(currentExpr.Body)), expr.Parameters);
                    }
                    else if (expr != null && currentExpr != null && nextBreakingLogic != null && nextBreakingLogic == LogicTypes.Or)
                    {
                        expr = Expression.Lambda<Func<RecipeModel, bool>>(Expression.Or(expr.Body, new ExpressionParameterReplacer(currentExpr.Parameters, expr.Parameters).Visit(currentExpr.Body)), expr.Parameters);
                    }
                    currentExpr = nonRelationField;
                    nextBreakingLogic = item.LogicalOperator == LogicTypes.And ? LogicTypes.And : LogicTypes.Or;
                }
                else if (item.LogicalOperator == LogicTypes.AndAlso)
                {
                    currentExpr = Expression.Lambda<Func<RecipeModel, bool>>(
                    Expression.AndAlso(currentExpr.Body,
                    new ExpressionParameterReplacer(nonRelationField.Parameters, currentExpr.Parameters)
                        .Visit(nonRelationField.Body)), currentExpr.Parameters);
                }
                else if (item.LogicalOperator == LogicTypes.OrElse)
                {
                    currentExpr = Expression.Lambda<Func<RecipeModel, bool>>(
                    Expression.OrElse(currentExpr.Body,
                    new ExpressionParameterReplacer(nonRelationField.Parameters, currentExpr.Parameters)
                        .Visit(nonRelationField.Body)), currentExpr.Parameters);
                }
                nextFollowsLogic = true; // Next Loop will use nextLogic as predicate behavior
            }

            if (currentExpr != null)
            {
                if (expr == null) { expr = currentExpr; }
                else if (expr != null && currentExpr != null && nextBreakingLogic != null && nextBreakingLogic == LogicTypes.And)
                {
                    expr = Expression.Lambda<Func<RecipeModel, bool>>(Expression.And(expr.Body, new ExpressionParameterReplacer(currentExpr.Parameters, expr.Parameters).Visit(currentExpr.Body)), expr.Parameters);
                }
                else if (expr != null && currentExpr != null && nextBreakingLogic != null && nextBreakingLogic == LogicTypes.Or)
                {
                    expr = Expression.Lambda<Func<RecipeModel, bool>>(Expression.Or(expr.Body, new ExpressionParameterReplacer(currentExpr.Parameters, expr.Parameters).Visit(currentExpr.Body)), expr.Parameters);
                }
            }
            // If no Condition load any 
            expr = expr == null ? p => p != null : expr;
            return query.Where(expr);
        }

        /// <summary>
        /// Query where given field condition are met.
        /// </summary>
        public static IEnumerable<RecipeModel> WhereConditionsMet(this IEnumerable<RecipeModel> query, List<RecipePredicateConditions> conditions)
        {
            if (conditions == null) { return query; }
            bool nextFollowsLogic = false;
            ApiServiceBase myServiceBase = new ApiServiceBase();
            LogicTypes? nextBreakingLogic = null;
            Expression<Func<RecipePublicModel, bool>> expr = null;
            Expression<Func<RecipePublicModel, bool>> currentExpr = null;
            foreach (var item in conditions)
            {
                Expression<Func<RecipePublicModel, bool>> nonRelationField = p => myServiceBase.ConditionTypeDelegator(item.Conditions,
                    p.GetType().GetPropertyInfoByName(item.Field.ToString()).GetValue(p), item.Value,
                    p.GetType().GetProperty(item.Field.ToString()).GetUnderlyingPropertyTypeIfPossible());

                if (!nextFollowsLogic)
                {
                    currentExpr = nonRelationField;

                }
                else if (item.LogicalOperator == LogicTypes.And || item.LogicalOperator == LogicTypes.Or)
                {
                    if (expr == null) { expr = currentExpr; }
                    else if (expr != null && currentExpr != null && nextBreakingLogic != null && nextBreakingLogic == LogicTypes.And)
                    {
                        expr = Expression.Lambda<Func<RecipePublicModel, bool>>(Expression.And(expr.Body, new ExpressionParameterReplacer(currentExpr.Parameters, expr.Parameters).Visit(currentExpr.Body)), expr.Parameters);
                    }
                    else if (expr != null && currentExpr != null && nextBreakingLogic != null && nextBreakingLogic == LogicTypes.Or)
                    {
                        expr = Expression.Lambda<Func<RecipePublicModel, bool>>(Expression.Or(expr.Body, new ExpressionParameterReplacer(currentExpr.Parameters, expr.Parameters).Visit(currentExpr.Body)), expr.Parameters);
                    }
                    currentExpr = nonRelationField;
                    nextBreakingLogic = item.LogicalOperator == LogicTypes.And ? LogicTypes.And : LogicTypes.Or;
                }
                else if (item.LogicalOperator == LogicTypes.AndAlso)
                {
                    currentExpr = Expression.Lambda<Func<RecipePublicModel, bool>>(
                    Expression.AndAlso(currentExpr.Body,
                    new ExpressionParameterReplacer(nonRelationField.Parameters, currentExpr.Parameters)
                        .Visit(nonRelationField.Body)), currentExpr.Parameters);
                }
                else if (item.LogicalOperator == LogicTypes.OrElse)
                {
                    currentExpr = Expression.Lambda<Func<RecipePublicModel, bool>>(
                    Expression.OrElse(currentExpr.Body,
                    new ExpressionParameterReplacer(nonRelationField.Parameters, currentExpr.Parameters)
                        .Visit(nonRelationField.Body)), currentExpr.Parameters);
                }
                nextFollowsLogic = true; // Next Loop will use nextLogic as predicate behavior
            }

            if (currentExpr != null)
            {
                if (expr == null) { expr = currentExpr; }
                else if (expr != null && currentExpr != null && nextBreakingLogic != null && nextBreakingLogic == LogicTypes.And)
                {
                    expr = Expression.Lambda<Func<RecipePublicModel, bool>>(Expression.And(expr.Body, new ExpressionParameterReplacer(currentExpr.Parameters, expr.Parameters).Visit(currentExpr.Body)), expr.Parameters);
                }
                else if (expr != null && currentExpr != null && nextBreakingLogic != null && nextBreakingLogic == LogicTypes.Or)
                {
                    expr = Expression.Lambda<Func<RecipePublicModel, bool>>(Expression.Or(expr.Body, new ExpressionParameterReplacer(currentExpr.Parameters, expr.Parameters).Visit(currentExpr.Body)), expr.Parameters);
                }
            }
            // If no Condition load any 
            expr = expr == null ? p => p != null : expr;
            Func<RecipePublicModel, bool> predFunc = expr.Compile();
            return query.Where(p => predFunc(p));
        }

        /// <summary>
        /// Convert user given field to real backing field from model.json and sort it by given direction.
        /// </summary>
        public static IOrderedEnumerable<RecipeModel> OrderFieldConvert(this IEnumerable<RecipeModel> query, RecipePredicateOrdering.Fields field, OrderType orderType)
        {
            switch (field)
            {
                case RecipePredicateOrdering.Fields.Name: 
 return orderType == OrderType.Ascending ? query.OrderBy(p => p.Name) : query.OrderByDescending(p => p.Name);
case RecipePredicateOrdering.Fields.Duration: 
 return orderType == OrderType.Ascending ? query.OrderBy(p => p.Duration) : query.OrderByDescending(p => p.Duration);

                //[FOREACH]=>[_FIELD_PUBLIC_FETCH_]
                //[{ 
                // case RecipePredicateOrdering.Fields._FIELD_NAME_:
                // return orderType == OrderType.Ascending ? query.OrderBy(p => p._FIELD_NAME_) : query.OrderByDescending(p => p._FIELD_NAME_);
                //}]
            }
            return null;
        }

        /// <summary>
        /// Convert user given field to real backing field from model.json and sort it by given direction.
        /// </summary>
        public static IOrderedEnumerable<RecipeModel> OrderFieldConvert(this IOrderedEnumerable<RecipeModel> query, RecipePredicateOrdering.Fields field, OrderType orderType)
        {
            switch (field)
            {

                case RecipePredicateOrdering.Fields.Name: 
 return orderType == OrderType.Ascending ? query.ThenBy(p => p.Name) : query.ThenByDescending(p => p.Name);
case RecipePredicateOrdering.Fields.Duration: 
 return orderType == OrderType.Ascending ? query.ThenBy(p => p.Duration) : query.ThenByDescending(p => p.Duration);

                //case RecipePredicateOrdering.Fields.Id:
                    //return orderType == OrderType.Ascending ? query.ThenBy(p => p.Id) : query.ThenByDescending(p => p.Id);
                default:
                    return query;
            }
        }

        /// <summary>
        /// Convert user given field to real backing field from model.json and sort it by given direction.
        /// </summary>
        public static IOrderedQueryable<RecipeModel> OrderFieldConvert(this IQueryable<RecipeModel> query, RecipePredicateOrdering.Fields field, OrderType orderType)
        {
            switch (field)
            {
                case RecipePredicateOrdering.Fields.Name: 
 return orderType == OrderType.Ascending ? query.OrderBy(p => p.Name) : query.OrderByDescending(p => p.Name);
case RecipePredicateOrdering.Fields.Duration: 
 return orderType == OrderType.Ascending ? query.OrderBy(p => p.Duration) : query.OrderByDescending(p => p.Duration);
                //_FOR_EACH_MODEL_PUBLIC_ORDERABLE_FIELD_
                //[{ 
                // case RecipePredicateOrdering.Fields._FIELD_NAME_:
                // return orderType == OrderType.Ascending ? query.OrderBy(p => p._FIELD_NAME_) : query.OrderByDescending(p => p._FIELD_NAME_);
                //}]
                default:
                    return null;
            }
        }

        /// <summary>
        /// Convert user given field to real backing field from model.json and sort it by given direction.
        /// </summary>
        public static IOrderedQueryable<RecipeModel> OrderFieldConvert(this IOrderedQueryable<RecipeModel> query, RecipePredicateOrdering.Fields field, OrderType orderType)
        {
            switch (field)
            {
                case RecipePredicateOrdering.Fields.Name: 
 return orderType == OrderType.Ascending ? query.ThenBy(p => p.Name) : query.ThenByDescending(p => p.Name);
case RecipePredicateOrdering.Fields.Duration: 
 return orderType == OrderType.Ascending ? query.ThenBy(p => p.Duration) : query.ThenByDescending(p => p.Duration);

                // case RecipePredicateOrdering.Fields.Id:
                //     return orderType == OrderType.Ascending ? query.ThenBy(p => p.Id) : query.ThenByDescending(p => p.Id);
                default:
                    return query;
            }
        }

        /// <summary>
        /// Order List by a given sets of rules.
        /// </summary>
        public static IQueryable<RecipeModel> OrderByMatching(this IQueryable<RecipeModel> query, List<RecipePredicateOrdering> order)
        {
            if (order == null) { return query; }
            bool notFirst = false;
            ApiServiceBase myServiceBase = new ApiServiceBase();
            IOrderedQueryable<RecipeModel> ordering = null;
            foreach (var item in order)
            {
                if (!notFirst)
                {
                    ordering = query.OrderFieldConvert(item.Field, item.Order);
                    notFirst = true;
                }
                else
                {
                    ordering = ordering.OrderFieldConvert(item.Field, item.Order);
                }
            }

            if (ordering == null)
            {
                return query;
            }

            return ordering;
        }

        /// <summary>
        /// Order List by a given sets of rules.
        /// </summary>
        public static IEnumerable<RecipeModel> OrderByMatching(this IEnumerable<RecipeModel> query, List<RecipePredicateOrdering> order)
        {
            if (order == null) { return query; }
            bool notFirst = false;
            ApiServiceBase myServiceBase = new ApiServiceBase();
            IOrderedEnumerable<RecipeModel> ordering = null;
            foreach (var item in order)
            {
                if (!notFirst)
                {
                    ordering = query.OrderFieldConvert(item.Field, item.Order);
                    notFirst = true;
                }
                else
                {
                    ordering = ordering.OrderFieldConvert(item.Field, item.Order);
                }
            }

            if (ordering == null)
            {
                return query;
            }

            return ordering;
        }
    }

}
